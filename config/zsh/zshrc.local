# -*- mode: sh; -*-
# vi:ft=zsh

# Disable flow control
stty -ixon

if [ "${TERM}" = "xterm-kitty" ]; then
  alias ssh="kitten ssh"
  alias transfer="kitten transfer"
  alias download="kitten transfer --direction download"
  alias upload="kitten transfer --direction upload"
fi

if [ "${TERM}" = "xterm-kitty" ] || [ "${TERM}" = "xterm-ghostty" ]; then
  alias icat="kitten icat"
  alias hrg="kitten hyperlinked_grep"
  alias show-key="kitten show-key"
fi

# different behaviour inside emacs
# courtesey of elken
if [ "${INSIDE_EMACS}" = "vterm" ]; then
  vterm_printf() {
    if [ -n "$TMUX" ]; then
      # Tell tmux to pass the escape sequences through
      printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
      # GNU screen (screen, screen-256color, screen-256color-bce)
      printf "\eP\e]%s\007\e\\" "$1"
    else
      printf "\e]%s\e\\" "$1"
    fi
  }

  vterm_cmd() {
    local vterm_elisp
    vterm_elisp=""
    while [ $# -gt 0 ]; do
      vterm_elisp="${vterm_elisp}"\"${${1//\\/'\\\\'}//\"/\\\"}\"
      shift
    done
    vterm_printf "51;E$vterm_elisp"
  }

  find_file() {
    vterm_cmd find-file "$(realpath -mq "${@:-.}")"
  }

  woman () {
    vterm_cmd woman $1
  }

  dired () {
    local patharg
    patharg="$(realpath -eq "${@:-.}")"

    if [ $? -eq 1 ]; then
       printf "No such file or directory\n"
       return 1
    fi

    vterm_cmd dired ${patharg}
  }

  ranger () {
    local patharg
    patharg="$(realpath -eq "${@:-.}")"

    if [ $? -eq 1 ]; then
       printf "No such file or directory\n"
       return 1
    fi

    # ranger needs a trailing slash to open the directory
    if [ -d "${patharg}" ]; then
       patharg="${patharg}/"
    fi

    vterm_cmd ranger ${patharg}
  }

  yazi () {
    local patharg
    patharg="$(realpath -eq "${@:-.}")"

    if [ $? -eq 1 ]; then
       printf "No such file or directory\n"
       return 1
    fi

    # ranger needs a trailing slash to open the directory
    if [ -d "${patharg}" ]; then
       patharg="${patharg}/"
    fi

    vterm_cmd ranger ${patharg}
  }

  alias find-file='find_file'
  alias ff='find_file'
  alias emacs='find_file'
  alias vim='find_file'
  alias nvim='find_file'
  alias clear='vterm_printf "51;Evterm-clear-scrollback";tput clear'
  alias man='woman'
  alias fm='dired'
fi

# Don't try to open EDITORs inside emacs
if [ -n "${INSIDE_EMACS}" ]; then
  export EDITOR="false"
fi

## Abk

abk[NN]=">/dev/null 2>&1"

## Functions

# Show public ip
function myip() {
  local flag
  case "$1" in
  "-6")
    flag="-6"
    ;;
  *)
    flag="-4"
    ;;
  esac
  print $(curl -s "${flag}" "https://icanhazip.com")
}

# print hex value of a number
function hex() {
  emulate -L zsh
  if [[ -n "$1" ]]; then
    printf "%x\n" $1
  else
    print 'Usage: hex <number-to-convert>'
    return 1
  fi
}

# optimise a pdf
function pdfopt() {
  # from https://askubuntu.com/questions/113544/how-can-i-reduce-the-file-size-of-a-scanned-pdf-file
  gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.5 -dNOPAUSE -dQUIET -dBATCH -dPrinted=false -sOutputFile="$2" "$1"
}

# swap files
function swap() {
  local TMPFILE=tmp.$$
  mv -n "$1" $TMPFILE && mv "$2" "$1" && mv $TMPFILE "$2"
}

## Prompt

# Virtualenv support
function virtual_env_prompt () {
   REPLY=${VIRTUAL_ENV+(${VIRTUAL_ENV:t}) }
}
grml_theme_add_token my-virtual-env -f virtual_env_prompt '%F{magenta}' '%f'

# grml's built in jobs prompt is a little verbose, so define one that just
# prints 'running':'suspended', and nothing if there are no jobs
# TODO: will currently leave space for ':(' even if it isn't there, fixable?
function n_jobs () {
  REPLY=${(M)#${jobstates%%:*}:#running}:${(M)#${jobstates%%:*}:#suspended}
  if [[ $REPLY == 0:0 ]]; then REPLY=; fi
  # echo $REPLY
}
grml_theme_add_token  my-jobs -f n_jobs '%F{green}' '%f '

# emit OSC-133;B in prompt
function emit-osc-133-b() {
  print -Pn "\e]133;B\e\\"
}

grml_theme_add_token osc-133-b -i emit-osc-133-b

zstyle ':prompt:grml:left:setup' items rc my-virtual-env change-root user at host path vcs percent osc-133-b
zstyle ':prompt:grml:right:setup' items my-jobs sad-smiley

## set command prediction from history, see 'man 1 zshcontrib'
zrcautoload predict-on &&
  zle -N predict-on &&
  zle -N predict-off &&
  bindkey "^X^Z" predict-on &&
  bindkey "^Z" predict-off

## Window title
function set-term-title-precmd() {
  emulate -L zsh
  print -rn -- $'\e]2;'${USER}@${HOST}: ${(V%):-'%~'}$'\a' >$TTY
}
function set-term-title-preexec() {
  emulate -L zsh
  print -rn -- $'\e]2;'${USER}@${HOST}: ${(V)1}$'\a' >$TTY
}
autoload -Uz add-zsh-hook
add-zsh-hook preexec set-term-title-preexec
add-zsh-hook precmd set-term-title-precmd
set-term-title-precmd

## Emit OSC-133;A, OSC-133;C and OSC-133;D
# see https://iterm2.com/documentation-escape-codes.html
function emit-osc-133-a() {
  print -Pn "\e]133;A\e\\"
}

function emit-osc-133-c() {
  print -Pn "\e]133;C\e\\"
}

function emit-osc-133-d() {
  print -Pn "\e]133;D;$?\e\\"
}

add-zsh-hook precmd emit-osc-133-d
add-zsh-hook precmd emit-osc-133-a
add-zsh-hook preexec emit-osc-133-c

## Autoload

# enable calculator
autoload zcalc

# enable zargs
autoload -U zargs

## Misc

# just type '...' to get '../..'
rationalise-dot() {
  local MATCH
  if [[ $LBUFFER =~ '(^|/| |	|'$'\n''|\||;|&)\.\.$' ]]; then
    LBUFFER+=/
    zle self-insert
    zle self-insert
  else
    zle self-insert
  fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
# without this, typing a . aborts incremental history search
bindkey -M isearch . self-insert

bindkey '\eq' push-line-or-edit

# emit OSC 7, see https://codeberg.org/dnkl/foot/wiki#user-content-bash-and-zsh
function osc7-pwd() {
    emulate -L zsh # also sets localoptions for us
    setopt extendedglob
    local LC_ALL=C
    printf '\e]7;file://%s%s\e\' $HOST ${PWD//(#m)([^@-Za-z&-;_~])/%${(l:2::0:)$(([##16]#MATCH))}}
}

function chpwd-osc7-pwd() {
    (( ZSH_SUBSHELL )) || osc7-pwd
}
add-zsh-hook -Uz chpwd chpwd-osc7-pwd

## changed completer settings
zstyle ':completion:*' completer _complete _correct _approximate

## ctrl-s will no longer freeze the terminal.
stty erase "^?"

## Completion

command mkdir -p ~/.zfunc

# poetry
if (( $+commands[poetry] )) && [[ ! -a ~/.zfunc/_poetry ]]; then
  poetry completions zsh > ~/.zfunc/_poetry
fi

fpath+=~/.zfunc

## END OF FILE #################################################################
