# -*- mode: sh; -*-
# vi:ft=zsh

# Set up thefuck
if type thefuck >/dev/null 2>&1; then
  eval $(thefuck --alias yikes)
fi

# Set up virtualenvwrapper
if type virtualenvwrapper.sh > /dev/null 2>&1; then
  export WORKON_HOME=~/.virtualenvs
  export PROJECT_HOME=~/code/python
  mkdir -p ${WORKON_HOME} ${PROJECT_HOME}
  source virtualenvwrapper.sh
fi

# Disable flow control
stty -ixon

## Environment

WORDCHARS='${WORDCHARS:s@/@}'

# Increase history size 10Ã—
HISTSIZE=50000
SAVEHIST=100000

# secrets
[ -f "${XDG_RUNTIME_DIR}/secrets/cachix_auth_token" ] \
  && export CACHIX_AUTH_TOKEN=$(<"${XDG_RUNTIME_DIR}/secrets/cachix_auth_token")

## Aliases

# Easy access to full zsh manual
alias manzsh='man zshall'

# Emacs client
alias ec="emacsclient -a '' -t"

## get top 10 shell commands:
alias top10='print -l ${(o)history%% *} | uniq -c | sort -nr | head -n 10'

alias doom='~/.emacs.d/bin/doom'
alias emacs='emacs & disown'
alias s='sudo $(fc -ln -1)'
alias killgpg='gpgconf --kill gpg-agent'

# easy sedding with perl
alias pie='perl -pi -e'

# test for truecolour support in terminal
# https://gist.github.com/XVilka/8346728
alias tctest='awk '\''BEGIN{
    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;
    for (colnum = 0; colnum<77; colnum++) {
        r = 255-(colnum*255/76);
        g = (colnum*510/76);
        b = (colnum*255/76);
        if (g>255) g = 510-g;
        printf "\033[48;2;%d;%d;%dm", r,g,b;
        printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
        printf "%s\033[0m", substr(s,colnum+1,1);
    }
    printf "\n";
}'\'''

# Julia daemon
alias juliad="julia --startup-file=no -e 'using DaemonMode; serve()'"
alias juliac='julia --startup-file=no -e "using DaemonMode; runargs()"'

# Cheatsheet
alias cs="bat -p ~/.local/share/zsh/zsh_cheatsheet.md"

# nixpkgs pr check
alias nixpkgs-revhead='nix-shell -p nixpkgs-review --run "nixpkgs-review rev HEAD"'

# Arion
if type arion >/dev/null 2>&1; then
  salias adown="arion down"
  salias apull="ionice -n 5 arion pull"
  salias aup="ionice -n 5 arion up -d"
fi

if type bat >/dev/null 2>&1; then
  # bat-powered less
  alias bless='bat -p --paging=always'
  export MANPAGER="sh -c 'col -bx | bat -l man -p'"
  export MANROFFOPT="-c"

  # bat-powered ripgrep
  if type batgrep >/dev/null 2>&1; then
    alias brg='batgrep'
  fi
fi

# use neovim if it exists
if type nvim >/dev/null 2>&1; then
  alias vim='nvim'
  alias vi='nvim -u NONE'
  export EDITOR=nvim
else
  export EDITOR=vim
fi

# rsync
alias rsync='rsync -avzhPHA --info=progress2'
alias srsync='rsync --info=progress2 -avzPhHAe ssh'

# update all python packages at once with pip
alias pipdate='sh -c "pip freeze --local | ag -v '\''^\-e'\'' | cut -d = -f 1  | xargs -n1 pip install -U"'
alias pip2date='sh -c "pip2 freeze --local | ag -v '\''^\-e'\'' | cut -d = -f 1  | xargs -n1 pip install -U"'

if [ "${TERM}" = "xterm-kitty" ]; then
  alias ssh="kitty +kitten ssh"
  alias hrg="kitty +kitten hyperlinked_grep"
  alias icat="kitty +kitten icat"
fi

# different behaviour inside emacs
# courtesey of elken
if [ "${INSIDE_EMACS}" = "vterm" ]; then
  vterm_printf() {
    if [ -n "$TMUX" ]; then
      # Tell tmux to pass the escape sequences through
      printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
      # GNU screen (screen, screen-256color, screen-256color-bce)
      printf "\eP\e]%s\007\e\\" "$1"
    else
      printf "\e]%s\e\\" "$1"
    fi
  }

  vterm_cmd() {
    local vterm_elisp
    vterm_elisp=""
    while [ $# -gt 0 ]; do
      vterm_elisp="${vterm_elisp}"\"${${1//\\/'\\\\'}//\"/\\\"}\"
      shift
    done
    vterm_printf "51;E$vterm_elisp"
  }

  find_file() {
    vterm_cmd find-file "$(realpath -mq "${@:-.}")"
  }

  woman () {
    vterm_cmd woman $1
  }

  dired () {
    local patharg
    patharg="$(realpath -eq "${@:-.}")"

    if [ $? -eq 1 ]; then
       printf "No such file or directory\n"
       return 1
    fi

    vterm_cmd dired ${patharg}
  }

  ranger () {
    local patharg
    patharg="$(realpath -eq "${@:-.}")"

    if [ $? -eq 1 ]; then
       printf "No such file or directory\n"
       return 1
    fi

    # ranger needs a trailing slash to open the directory
    if [ -d "${patharg}" ]; then
       patharg="${patharg}/"
    fi

    vterm_cmd ranger ${patharg}
  }

  alias find-file='find_file'
  alias ff='find_file'
  alias emacs='find_file'
  alias vim='find_file'
  alias nvim='find_file'
  alias clear='vterm_printf "51;Evterm-clear-scrollback";tput clear'
  alias man='woman'
  alias fm='dired'
fi

# Don't try to open EDITORs inside emacs
if [ -n "${INSIDE_EMACS}" ]; then
  export EDITOR="false"
fi

if type pacman >/dev/null 2>&1; then
  # run pacman as root
  salias pacman=pacman

  # clean orphan packages with pacman
  salias deorphan='pacman -Rns $(pacman -Qtdq)'

  # find .pacnew, .pacsave, and pacorig files
  if type fd >/dev/null 2>&1; then
    salias pacfiles='fd --xdev ".+\.pac(new|save|orig)" /'
  else
    salias pacfiles='find / -xdev -regextype posix-extended -regex ".+\.pac(new|save|orig)"'
  fi

  # sort installed packages by size
  alias pacsize='expac "%m\t%n" | sort -h'
fi

# find broken symlinks
alias brokenlinks='find /var -path /proc -prune -o -type l -! -exec test -e {} \; -print'

# diff files with escalated privilege
alias sudodiff='VISUAL="$EDITOR -d" sudoedit'

# shutdown and the like
alias poweroff='systemctl poweroff'
alias shutdown='systemctl poweroff'
alias reboot='systemctl reboot'
alias suspend='systemctl suspend'
alias hibernate='systemctl hibernate'
alias hybrid-sleep='systemctl hybrid-sleep'

## Abk

abk[NN]=">/dev/null 2>&1"

## Functions

# Show public ip
function myip() {
  local flag
  case "$1" in
  "-4")
    flag=""
    ;;
  "-6")
    flag="-6"
    ;;
  *)
    flag=""
    ;;
  esac
  printf $(curl -s "${flag}" "https://icanhazip.com")'\n'
}


# List all occurrences of program in current PATH
function plap() {
  emulate -L zsh
  setopt extended_glob

   if [[ $# = 0 ]] ; then
       echo "Usage:    $0 program"
       echo "Example:  $0 zsh"
       echo "Lists all occurrences of program in the current PATH."
   else
       ls -l ${^path}/$1(.*)#(*N)
   fi
}

# print hex value of a number
function hex() {
  emulate -L zsh
  if [[ -n "$1" ]]; then
    printf "%x\n" $1
  else
    print 'Usage: hex <number-to-convert>'
    return 1
  fi
}

# Find out which libs define a symbol
function lcheck() {
   if [[ -n "$1" ]] ; then
       nm -go /usr/lib/lib*.a 2>/dev/null | grep ":[[:xdigit:]]\{8\} . .*$1"
   else
       echo "Usage: lcheck <function>" >&2
   fi
}

# optimise a pdf
function pdfopt() {
  # from https://askubuntu.com/questions/113544/how-can-i-reduce-the-file-size-of-a-scanned-pdf-file
  gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.5 -dNOPAUSE -dQUIET -dBATCH -dPrinted=false -sOutputFile="$2" "$1"
}

# swap files
function swap() {
  local TMPFILE=tmp.$$
  mv -n "$1" $TMPFILE && mv "$2" "$1" && mv $TMPFILE "$2"
}

## Prompt

# Virtualenv support
function virtual_env_prompt () {
   REPLY=${VIRTUAL_ENV+(${VIRTUAL_ENV:t}) }
}
grml_theme_add_token my-virtual-env -f virtual_env_prompt '%F{magenta}' '%f'

# grml's built in jobs prompt is a little verbose, so define one that just
# prints 'running':'suspended', and nothing if there are no jobs
# TODO: will currently leave space for ':(' even if it isn't there, fixable?
function n_jobs () {
  REPLY=${(M)#${jobstates%%:*}:#running}:${(M)#${jobstates%%:*}:#suspended}
  if [[ $REPLY == 0:0 ]]; then REPLY=; fi
  # echo $REPLY
}
grml_theme_add_token  my-jobs -f n_jobs '%F{green}' '%f '

# emit OSC-133;B in prompt
function emit-osc-133-b() {
  print -Pn "\e]133;B\e\\"
}

grml_theme_add_token osc-133-b -i emit-osc-133-b

zstyle ':prompt:grml:left:setup' items rc my-virtual-env change-root user at host path vcs percent osc-133-b
zstyle ':prompt:grml:right:setup' items my-jobs sad-smiley

## set command prediction from history, see 'man 1 zshcontrib'
is4 && zrcautoload predict-on &&
  zle -N predict-on &&
  zle -N predict-off &&
  bindkey "^X^Z" predict-on &&
  bindkey "^Z" predict-off

## Window title
function set-term-title-precmd() {
  emulate -L zsh
  print -rn -- $'\e]2;'${USER}@${HOST}: ${(V%):-'%~'}$'\a' >$TTY
}
function set-term-title-preexec() {
  emulate -L zsh
  print -rn -- $'\e]2;'${USER}@${HOST}: ${(V)1}$'\a' >$TTY
}
autoload -Uz add-zsh-hook
add-zsh-hook preexec set-term-title-preexec
add-zsh-hook precmd set-term-title-precmd
set-term-title-precmd

## Emit OSC-133;A, OSC-133;C and OSC-133;D
# see https://iterm2.com/documentation-escape-codes.html
function emit-osc-133-a() {
  print -Pn "\e]133;A\e\\"
}

function emit-osc-133-c() {
  print -Pn "\e]133;C\e\\"
}

function emit-osc-133-d() {
  print -Pn "\e]133;D;$?\e\\"
}

add-zsh-hook precmd emit-osc-133-d
add-zsh-hook precmd emit-osc-133-a
add-zsh-hook preexec emit-osc-133-c

## Options

# warning if file exists ('cat /dev/null > ~/.zshrc')
setopt NO_clobber

# Allow comments even in interactive shells
setopt interactivecomments

## Autoload

# enable calculator
autoload zcalc

## Misc

# just type '...' to get '../..'
rationalise-dot() {
  local MATCH
  if [[ $LBUFFER =~ '(^|/| |	|'$'\n''|\||;|&)\.\.$' ]]; then
    LBUFFER+=/
    zle self-insert
    zle self-insert
  else
    zle self-insert
  fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
# without this, typing a . aborts incremental history search
bindkey -M isearch . self-insert

bindkey '\eq' push-line-or-edit

# emit OSC 7, see https://codeberg.org/dnkl/foot/wiki#user-content-bash-and-zsh
function osc7-pwd() {
    emulate -L zsh # also sets localoptions for us
    setopt extendedglob
    local LC_ALL=C
    printf '\e]7;file://%s%s\e\' $HOST ${PWD//(#m)([^@-Za-z&-;_~])/%${(l:2::0:)$(([##16]#MATCH))}}
}

function chpwd-osc7-pwd() {
    (( ZSH_SUBSHELL )) || osc7-pwd
}
add-zsh-hook -Uz chpwd chpwd-osc7-pwd

## changed completer settings
zstyle ':completion:*' completer _complete _correct _approximate

## ctrl-s will no longer freeze the terminal.
stty erase "^?"

## Completion

command mkdir -p ~/.zfunc

# poetry
if (( $+commands[poetry] )) && [[ ! -a ~/.zfunc/_poetry ]]; then
  poetry completions zsh > ~/.zfunc/_poetry
fi

fpath+=~/.zfunc

## Work stuff

# Functions for interacting with annotation server
function get_content() {
    curl -s 'localhost:14100/extract/content' -X POST -F file=@"${1}" -H 'Accept: application/json' | jq
}

function _wrap_content() {
    local id language

    # deterministically calculate an ID from the content.json hash
    id="$(xxhsum "${1}")"
    id=-$((16#${ID%% *}))

    language="en"

    jq "{\"annotations\": [{\"content\": {\"language\": \"${language}\"}, \"position\": [\"0\", null], \"updated_by\": \"2\", \"id\": \"lang_ann\", \"type\": \"language\"}], \"content\": ., \"media_type\": null, \"room_id\": 1000, \"id\": ${id}}" "${1}"
}

function _compute_cbert_vectors() {
    _wrap_content "${1}" | curl -s 'localhost:4400/annotate/sentence_vectors?user_id=2' -X POST -T - -H 'Accept: application/json' -H 'Content-Type: application/json'
}

function annotate_contracttypes() {
    _compute_cbert_vectors "${1}" > /dev/null
    _wrap_content "${1}" | curl -s 'localhost:4400/annotate/concepts?user_id=2&type=contracttype' -X POST -T - -H 'Accept: application/json' -H 'Content-Type: application/json' | jq
}

function annotate_clauses() {
    _compute_cbert_vectors "${1}" > /dev/null
    _wrap_content "${1}" | curl -s 'localhost:4400/annotate/concepts?user_id=2&type=fragment:clause' -X POST -T - -H 'Accept: application/json' -H 'Content-Type: application/json' | jq
}

function annotate_entities() {
    _compute_cbert_vectors "${1}" > /dev/null
    local content query
    local -a entities

    content="${1}"

    shift

    if [ ${#@[@]} -eq 0 ]; then
        entities=( "area" "currency" "datetime" "identifier" "law" "location" "paty" "percent" "timeperiod" "titles" "structure" )
    else
        entities=( "$@" )
    fi

    query=""
    for entity in $entities; do
        query+="&type=entity:${entity}"
    done

    _wrap_content "${content}" | curl -s "localhost:4400/annotate/entities?user_id=2${query}" -X POST -T - -H 'Accept: application/json' -H 'Content-Type: application/json' | jq
}

alias xsvt="xsv table"

## Syntax highlighting

# MUST be done last!
if [ -f "/usr/share/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh" ]; then
  # Arch linux if zsh-fast-syntax-highlighting is installed
  source /usr/share/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh
fi

## Customise highlighting (if enabled)
if typeset -f fast-theme > /dev/null; then
  # on NixOS we are spammed with complains about a ro fs, so redirect everything to /dev/null
  # fast-theme -q default &> /dev/null
  fast-theme -q XDG:overlay &> /dev/null  # load my theme customisations
fi

## END OF FILE #################################################################
