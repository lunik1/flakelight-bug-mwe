#!/usr/bin/env bb
;; mode: clojure -*-
;; vim: ft=clojure

(ns ploy
  (:require
   [babashka.cli :as cli]
   [babashka.fs :as fs]
   [babashka.process :refer [check shell pb pipeline process]]
   [clojure.set :as set]
   [clojure.string :as str]
   [cheshire.core :as json]))

(def ^:private CACHIX-CACHE "lunik1-nix-config")

(defn- get-home
  []
  (System/getProperty "user.home"))

(defn- get-hostname
  []
  (.getHostName (java.net.InetAddress/getLocalHost)))

(defn- exit-on-fail
  [procfn]
  (fn
    [& args]
    (try
      (apply procfn args)
      (catch clojure.lang.ExceptionInfo e
        (prn (ex-data e))
        (-> e ex-data :exit System/exit)))))

(def ^:private try-shell
  (exit-on-fail shell))

(defn- nix
  {:arglists '([opts? & args])}

  [& args]
  (let [[opts args] (if (map? (first args))
                      [(first args) (rest args)]
                      [{} args])]
    (apply try-shell opts "nix" "--experimental-features" "nix-command flakes" args)))

(defn- nom
  {:arglists '([opts? & args])}

  [& args]
  (let [[opts args] (if (map? (first args))
                      [(first args) (rest args)]
                      [{} args])]
    (apply try-shell opts "nom" args)))

(def ^:private try-nix
  (exit-on-fail nix))

(def ^:private try-nom
  (exit-on-fail nom))

(def ^:private nix-platforms
  (memoize
   (fn []
     (let [nix-config (-> (try-nix {:out :string} "config" "show" "--json")
                          :out
                          (json/parse-string true))]
       (set (conj (-> nix-config :extra-platforms :value)
                  (-> nix-config :system :value)))))))

(defn- uncomitted-changes?
  []
  (-> (process "git" "diff" "--quiet" "HEAD")
      deref
      :exit
      (not= 0)))

(defn- super-user?
  []
  (or (= "root" (System/getProperty "user.name"))
      (= "0" (System/getenv "UID"))))

(def ^:private flake-outputs
  (memoize
   (fn []
     (-> (try-nix {:out :string} "flake" "show" "--json" "--all-systems")
         :out
         (json/parse-string true)))))

(def ^:private devshell-outputs
  (memoize
   (fn []
     (->> (flake-outputs)
          :devShells
          keys
          (map name)
          set
          (set/intersection (nix-platforms))
          (map #(format ".#devShells.%s.default" (name %)))))))

(defn- host->output
  [host]
  (format ".#nixosConfigurations.%s.config.system.build.toplevel" host))

(defn- home->output
  [home]
  (format ".#homeConfigurations.%s.activationPackage" home))

(def ^:private hosts
  (memoize
   (fn []
     (->> (flake-outputs)
          :nixosConfigurations
          keys
          (map name)
          set))))

(def ^:private homes
  (memoize
   (fn []
     ;; home configurations are not exposed by `nix flake show` but we can find
     ;; them in :checks when using flakelight
     (->> (flake-outputs)
          :checks
          vals
          (reduce merge)
          keys
          (map name)
          (filter #(str/starts-with? % "home-"))
          (map #(str/replace % #"^home-" ""))
          set))))

(def ^:private outputs
  (memoize
   (fn []
     (concat (devshell-outputs)
             (map host->output (hosts))
             (map home->output (homes))))))

(def ^:private push-to-cachix!
  (partial
   try-shell
   "cachix" "push"
   CACHIX-CACHE
   "-j" (str (.availableProcessors (Runtime/getRuntime)))))

(defn build-all
  [_]
  (apply try-nom "build" "--no-link" "--fallback" (outputs)))

(defn install-home!
  [{{hostname :hostname} :opts}]
  (let [hostname (or hostname
                     (let [hostname (get-hostname)]
                       (println (format "No hostname provided using '%s'" hostname))
                       hostname))]
    (try-nom "build" "--fallback" "-o" "./result" (home->output hostname))

    ;; mimeapps.list has a bad habit of being modified and getting in the way
    (fs/delete-if-exists (format "%s/.config/mimeapps.list" (get-home)))

    ;; activate the new configuration
    (try-shell "./result/activate")))

(defn install-system!
  [{{hostname :hostname operation :operation} :opts}]
  (let [hostname (or hostname
                     (let [hostname (get-hostname)]
                       (println (format "No hostname provided using '%s'" hostname))
                       hostname))]
    (if (super-user?)
      (do
        (fs/delete-tree "/etc/nixos")
        (fs/copy-tree "." "/etc/nixos")

        (exit-on-fail
         (run! check
               (pipeline (pb {:err :out} "nixos-rebuild" operation "--flake" (format "/etc/nixos#%s" hostname))
                         (pb {:out :inherit :err :inherit} "nom")))))
      (do
        (println "Requires super user, aborting.")
        (System/exit 19)))))

(defn deploy-system!
  [{{host :host target :target} :opts}]
  (let [target (or target host)]
    (exit-on-fail
     (run!
      check
      (pipeline (pb {:in :inherit :err :out}
                    "nixos-rebuild" "switch" "--flake" (format ".#%s" host) "--sudo" "--ask-sudo-password" "--target-host" target)
                (pb {:out :inherit :err :inherit} "nom"))))))

(defn populate-cache!
  [_]
  (if (uncomitted-changes?)
    (do
      (println "Refusing to populate cache with uncommitted changes.")
      (System/exit 1))
    (as-> (outputs) $
      (apply try-nom {:out :string} "build" "--fallback" "--no-link" "--json" $)
      (:out $)
      (json/parse-string $ true)
      (map #(get-in % [:outputs :out]) $)
      (apply push-to-cachix! $))))

(defn nix-check
  [_]
  (-> (try-nix {:continue true} "flake" "check")
      :exit
      System/exit))

(defn update-lockfile! [_]
  (try-nix "flake" "update" "--flake" "." "--commit-lock-file"))

(defn default [_]
  (println "Invalid command.")
  (System/exit 1))

(def table
  [{:cmds ["update"] :fn update-lockfile!}
   {:cmds ["build-all"] :fn build-all}
   {:cmds ["cache"] :fn populate-cache!}
   {:cmds ["check"] :fn nix-check}
   {:cmds ["home"]
    :fn install-home!
    :args->opts [:hostname]
    :spec {:hostname {:validate #(contains? (homes) %)}}}
   {:cmds ["system"]
    :fn install-system!
    :args->opts [:hostname]
    :spec {:hostname {:validate #(contains? (hosts) %)}
           :operation {:default "switch"
                       :alias :p
                       :validate #(contains? #{"switch" "boot" "test" "build"} %)}}}
   {:cmds ["remote"]
    :fn deploy-system!
    :args->opts [:host :target]
    :spec {:host {:validate #(contains? (hosts) %)}}}
   {:cmds [] :fn default}])

(defn -main [args]
  ;; use :restrict true in next release https://github.com/babashka/cli/issues/98
  (cli/dispatch table args {:error-fn #(println (:msg %))}))

(-main *command-line-args*)
