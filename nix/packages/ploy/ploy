#!/usr/bin/env bb
;; mode: clojure -*-
;; vim: ft=clojure

(ns ploy
  (:require
   [babashka.cli :as cli]
   [babashka.fs :as fs]
   [babashka.process :refer [check shell pb pipeline process]]
   [clojure.set :as set]
   [clojure.string :as str]
   [cheshire.core :as json]))

(def ^:private CACHIX-CACHE "lunik1-nix-config")

(defn- get-home
  []
  (System/getProperty "user.home"))

(defn- get-hostname
  []
  (.getHostName (java.net.InetAddress/getLocalHost)))

(defn- exit-on-fail
  [procfn]
  (fn
    [& args]
    (try
      (apply procfn args)
      (catch clojure.lang.ExceptionInfo e
        (prn (ex-data e))
        (-> e ex-data :exit System/exit)))))

(def ^:private try-shell
  (exit-on-fail shell))

(defn- nix
  {:arglists '([opts? & args])}

  [& args]
  (let [[opts args] (if (map? (first args))
                      [(first args) (rest args)]
                      [{} args])]
    (apply try-shell opts "nix" "--experimental-features" "nix-command flakes" args)))

(defn- nom
  {:arglists '([opts? & args])}

  [& args]
  (let [[opts args] (if (map? (first args))
                      [(first args) (rest args)]
                      [{} args])]
    (apply try-shell opts "nom" args)))

(def ^:private try-nix
  (exit-on-fail nix))

(def ^:private try-nom
  (exit-on-fail nom))

(def ^:private nix-platforms
  (memoize
   (fn []
     (let [nix-config (-> (try-nix {:out :string} "config" "show" "--json")
                          :out
                          (json/parse-string true))]
       (set (conj (-> nix-config :extra-platforms :value)
                  (-> nix-config :system :value)))))))

(defn- uncomitted-changes?
  []
  (-> (process "git" "diff" "--quiet" "HEAD")
      deref
      :exit
      (not= 0)))

(defn command-exists?
  [cmd]
  (-> (process ["which" cmd])
      deref
      :exit
      (= 0)))

(defn- super-user?
  []
  (or (= "root" (System/getProperty "user.name"))
      (= "0" (System/getenv "UID"))))

(def ^:private container-image
  (memoize
   (fn [container]
     (-> (try-shell {:out :string} "podman" "inspect" container "--format" "{{.ImageName}}")
         :out
         str/trim))))

(defn- image-digest
  [image]
  (-> (try-shell {:out :string} "podman" "inspect" image "--format" "{{index .RepoDigests 0}}")))

(defn- pull-image!
  [image]
  (try-shell "podman" "pull" image))

(defn- restart-container!
  [container]
  (println (format "Restarting %s" container))
  (try-shell "systemctl" "restart" (format "podman-%s.service" container)))

(defn- containers
  []
  (->> (try-shell
        {:out :string}
        "systemctl" "list-units" "-t" "service" "--full" "--all" "--plain" "--no-legend" "podman-*")
       :out
       str/split-lines
       (map (comp
             second
             first
             #(re-seq #"^podman-(\w+).service$" %)
             first
             #(str/split % #"\s+")))
       (remove nil?)))

(def ^:private flake-outputs
  (memoize
   (fn []
     (-> (try-nix {:out :string :err :string} "flake" "show" "--json")
         :out
         (json/parse-string true)))))

(def ^:private devshell-outputs
  (memoize
   (fn []
     (->> (flake-outputs)
          :devShells
          keys
          (map name)
          set
          (set/intersection (nix-platforms))
          (map #(format ".#devShells.%s.default" (name %)))))))

(defn- host->output
  [host]
  (format ".#nixosConfigurations.%s.config.system.build.toplevel" host))

(defn- home->output
  [home]
  (format ".#homeConfigurations.%s.activationPackage" home))

(def ^:private hosts
  (memoize
   (fn []
     (->> (flake-outputs)
          :nixosConfigurations
          keys
          (map name)
          set))))

(def ^:private homes
  (memoize
   (fn []
     ;; home configurations are not exposed by `nix flake show` but we can find
     ;; them in :checks when using flakelight
     (->> (flake-outputs)
          :checks
          vals
          (reduce merge)
          keys
          (map name)
          (filter #(str/starts-with? % "home-"))
          (map #(str/replace % #"^home-" ""))
          set))))

(def ^:private outputs
  (memoize
   (fn []
     (concat (devshell-outputs)
             (map host->output (hosts))
             (map home->output (homes))))))

(def ^:private push-to-cachix!
  (partial
   try-shell
   "cachix" "push"
   CACHIX-CACHE
   "-j" (str (.availableProcessors (Runtime/getRuntime)))))

(defn- maybe-update-font-cache!
  []
  (when (command-exists? "fc-cache")
    (println "Updating font cache.")
    (try
      (shell "fc-cache")
      (catch clojure.lang.ExceptionInfo _
        (binding [*out* *err*]
          (println "fc-cache failed"))))))

(defn build-all
  [_]
  (apply try-nom "build" (outputs)))

(defn install-home!
  [{{hostname :hostname} :opts}]
  (let [hostname (or hostname
                     (let [hostname (get-hostname)]
                       (println (format "No hostname provided using '%s'" hostname))
                       hostname))]
    (try-nom "build" "-o" "./result" (home->output hostname))

    ;; mimeapps.list has a bad habit of being modified and getting in the way
    (fs/delete-if-exists (format "%s/.config/mimeapps.list" (get-home)))

    ;; activate the new configuration
    (try-shell "./result/activate")

    (maybe-update-font-cache!)))

(defn install-system!
  [{{hostname :hostname operation :operation} :opts}]
  (let [hostname (or hostname
                     (let [hostname (get-hostname)]
                       (println (format "No hostname provided using '%s'" hostname))
                       hostname))]
    (if (super-user?)
      (do
        (fs/delete-tree "/etc/nixos")
        (fs/copy-tree "." "/etc/nixos")

        (exit-on-fail
         (run! check
               (pipeline (pb {:err :out} "nixos-rebuild" operation "--flake" (format "/etc/nixos#%s" hostname))
                         (pb {:out :inherit :err :inherit} "nom"))))

        (maybe-update-font-cache!))
      (do
        (println "Requires super user, aborting.")
        (System/exit 19)))))

(defn populate-cache!
  [_]
  (if (uncomitted-changes?)
    (do
      (println "Refusing to populate cache with uncommitted changes.")
      (System/exit 1))
    (as-> (outputs) $
      (apply try-nom {:out :string} "build" "--json" $)
      (:out $)
      (json/parse-string $ true)
      (map #(get-in % [:outputs :out]) $)
      (apply push-to-cachix! $))))

(defn update-containers!
  [_]
  (if (super-user?)
    (let [containers (containers)
          current-digests (->> containers
                               (map (comp #(vector % (image-digest %))
                                          container-image))
                               (into {}))
          images (keys current-digests)]
      (run! pull-image! images)
      (let [new-digests (->> images
                             (map #(vector % (image-digest %)))
                             (into {}))]
        (run!
         restart-container!
         (filter
          #(not= (current-digests (container-image %))
                 (new-digests (container-image %)))
          containers))))
    (do
      (println "Requires super user, aborting.")
      (System/exit 19))))

(defn nix-check
  [_]
  (-> (try-nix {:continue true} "flake" "check")
      :exit
      System/exit))

(defn update-lockfile! [_]
  (try-nix "flake" "update" "--flake" "." "--commit-lock-file"))

(defn default [_]
  (println "Invalid command.")
  (System/exit 1))

(def table
  [{:cmds ["update"] :fn update-lockfile!}
   {:cmds ["build-all"] :fn build-all}
   {:cmds ["cache"] :fn populate-cache!}
   {:cmds ["check"] :fn nix-check}
   {:cmds ["home"]
    :fn install-home!
    :args->opts [:hostname]
    :spec {:hostname {:validate #(contains? (homes) %)}}}
   {:cmds ["system"]
    :fn install-system!
    :args->opts [:hostname]
    :spec {:hostname {:validate #(contains? (hosts) %)}
           :operation {:default "switch"
                       :alias :p
                       :validate #(contains? #{"switch" "boot" "test" "build"} %)}}}
   {:cmds ["update-containers"] :fn update-containers!}
   {:cmds [] :fn default}])

(defn -main [args]
  ;; use :restrict true in next release https://github.com/babashka/cli/issues/98
  (cli/dispatch table args {:error-fn #(println (:msg %))}))

(-main *command-line-args*)
